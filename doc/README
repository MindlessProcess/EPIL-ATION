-----------------
|| EPIL(ATION)  |
-----------------

------------
| Summary: |
------------
1. What is Epil ?
  1.1 A C++ focused library
  1.2 Designed for runtime modification
2. Epil's architecture
  2.1 3 main parts
  2.2 The user-interface
  2.3 Core and Modules 
  2.4 The Util side
3. How-to
  3.1 Make a program Epil-friendly
  3.2 Run Epil
  3.3 Short examples
4. Applications examples
  4.1 Signal handling application
  4.2 Exception catcher application
5. Credits


=====================================


1. What is Epil ?
  1.1 A C++ focused library
    Epil is a C++ static library composed of several classes structured in different sections.
    The main goal of Epil is a program-inside utilization, to be implemented in an existing program.

  1.2 Designed for runtime modification
    Once implemented in one's program, Epil allows the latter to modify itself during runtime.
    Thus, it permits rewriting, recompiling and rerunning a source code while the programm is running.
    In other words, Epil grants a human-free control of a program, avoiding runtime errors and halts.

2. Epil's architecture
  2.1 Three main parts
    Epil is divided in three main parts, only two being really usable by the program.
    When you want to use Epil you should instanciate an Epil object preferably in the highest call scope.

  2.2 The user-interface
    The user-interface is represented by the Profile object. You should create one after instanciation.
    The user is now free to create a list of Action within a Profile object. The Actions should be added
    in the Profile with: setAction(my_action).
    To integrate the Profile in Epil, the user should use: loadProfile(my_profile) from the Epil object.
    
  2.3 Core and Modules
    The Modules are all the necessary tools for a user to create different Actions. The available actions
    are:
	-ActionWrite (please read below)
	-ActionCompile
	-ActionExec
    The ActionWrite will need a BlockList tool to set a range of lines to read/write from a file. 
    BlockList can be instanciated with a pair of ints (std::pair<int, int>) or a list of pair of ints

  2.4 The Utils side
    l
3. How-to
  3.1 Make a program Epil-friendly
  3.2 Run Epil
  3.3 Short examples
4. Applications examples
  4.1 Signal handling application
  4.2 Exception catcher application
5. Credits
  Epil is developped by Lyoma Guillou and Lucas Merlette since January 2014.
  It is an Epitech free project of the third year.


===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================

Steps list :
-modify code	CS
-recompile	CS
-re execute	CS
-action list	CA
-set action	CA
-del action	CA
-get action	CA
-next action	CA
-apply action	CA

CS -> Class System
CA -> Class Action

Module SHAVE =
Structure
Handling
Algorithmic
Variable
Envelops

Module HAIR =
Human
Advanced
Interfaced
Requests

### Project Applications Ideas ###

1. Signal handling (SIGSEGV, SIGPIPE, SIGQUIT, SIGBUS... etc. etc.)
2. Undefined Behavior (exceptions, debugging)
3. Conception building from scrap code

1. - Signal handling -

   1.1 - The signal overloading

       If your program sends a signal you wish to manage when it occurs
       EPIL library should be called within the signal handling for all
       the signals you want to catch.

   1.2 - Common signals

       Common signals that are expected to be used are the Segmentation
       Errors from memory allocation errors. EPIL should not be used
       for glibc errors where the problem comes from memory corruption.

2. - Undefined Behavior -

   2.1 - Exceptions

       You could call EPIL in every exceptions you have catched to
       manually change the behavior on the exception throwed

   2.2 - Debugging

       EPIL can also be called for debugging purposes where you wish to
       test different behaviors, because the editing, recompiling and
       re-execution are simplified.

3. - Conception building from scrap code -

   3.1 - Simple implementations

       Implementations can be very simple but can also contain bugs.
       EPIL can be handy to manage this kind of issues if a bug is to
       be found on any short written codes.
